package se.tre.freki.storage.cassandra.query;

import se.tre.freki.query.QueryException;
import se.tre.freki.storage.cassandra.ExhaustedResultSet;
import se.tre.freki.utils.AsyncIterator;

import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.ResultSetFuture;
import com.datastax.driver.core.Row;
import com.google.common.base.Function;
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.concurrent.ExecutionException;

/**
 * An iterator implementation that speculatively fetches the next partition when it detects that the
 * current one is close to being exhausted. Whether there are any more elements to get without
 * fetching can be checked by calling {@link #hasMoreWithoutFetching()} and {@link #fetchMore()} can
 * be called without blocking to get a future that {@link ListenableFuture#isDone()} once the fetch
 * is complete.
 *
 * <p>The partition keys are generated by the provided iterator and the partitions are fetched using
 * the provided fetch function.
 *
 * @param <K> The type of the partition key
 */
public class SpeculativePartitionIterator<K> implements AsyncIterator<Row> {
  private static final Logger LOG = LoggerFactory.getLogger(SpeculativePartitionIterator.class);

  private final Function<K, ResultSetFuture> fetchFunction;
  private final Iterator<K> partitionKeyGenerator;

  private ResultSet currentResultSet;
  private ListenableFuture<ResultSet> nextResultSet;

  /**
   * Create a new iterator that reads partition keys from the provided {@link
   * #partitionKeyGenerator} and loads the partitions using the {@link #fetchFunction}.
   *
   * @param partitionKeyGenerator An iterator that generates partition keys
   * @param fetchFunction A function that loads partitions given the partition keys generated by the
   * provided iterator
   */
  public SpeculativePartitionIterator(final Iterator<K> partitionKeyGenerator,
                                      final Function<K, ResultSetFuture> fetchFunction) {
    this.partitionKeyGenerator = partitionKeyGenerator;
    this.fetchFunction = fetchFunction;

    currentResultSet = new ExhaustedResultSet();
    nextResultSet = fetchNextPartition();
  }

  @Override
  public boolean hasMoreWithoutFetching() {
    return currentResultSet.getAvailableWithoutFetching() > 0;
  }

  @Override
  public ListenableFuture<Void> fetchMore() {
    if (currentResultSet.isExhausted()) {
      return Futures.transform(nextPartitionResultSet(), new Function<ResultSet, Void>() {
        @Override
        public Void apply(final ResultSet fetchedResultSet) {
          currentResultSet = fetchedResultSet;
          return null;
        }
      });
    } else if (currentResultSet.getAvailableWithoutFetching() == 0) {
      return currentResultSet.fetchMoreResults();
    }

    return Futures.immediateFuture(null);
  }

  @Override
  public boolean hasNext() {
    if (currentResultSet.isExhausted()) {
      try {
        currentResultSet = nextPartitionResultSet().get();
      } catch (ExecutionException e) {
        throw new QueryException("Fetch of next partition threw an exception", e);
      } catch (InterruptedException e) {
        throw new QueryException("Interrupted while waiting for next partition", e);
      }
      return !currentResultSet.isExhausted();
    }

    return true;
  }

  @Override
  public Row next() {
    checkHasNext("There are no more rows to iterate over");
    return currentResultSet.one();
  }

  private void checkHasNext(final String message) {
    if (!hasNext()) {
      throw new NoSuchElementException(message);
    }
  }

  /**
   * Blocks and waits for {@link #nextResultSet} to be done and starts fetching the next partition.
   *
   * @return The result set of the partition being loaded by {@link #nextResultSet}
   */
  private ListenableFuture<ResultSet> nextPartitionResultSet() {
    final ListenableFuture<ResultSet> fetchedResultSet = nextResultSet;
    nextResultSet = fetchNextPartition();

    if (!fetchedResultSet.isDone()) {
      LOG.debug("Waiting for next partition {} to finish loading", nextResultSet);
    } else {
      LOG.trace("Load of next partition {} already finished", nextResultSet);
    }

    return fetchedResultSet;
  }

  /**
   * Start fetching the next partition. If there are no more partitions to fetch an immidiate future
   * will be returned with an exhausted result set.
   *
   * @return A future that on completion will contain the result set of the next partition
   */
  private ListenableFuture<ResultSet> fetchNextPartition() {
    if (!partitionKeyGenerator.hasNext()) {
      LOG.trace("Told to fetch the next partition but partition key generator is exhausted");
      return Futures.immediateFuture(new ExhaustedResultSet());
    }

    final K nextPartitionKey = partitionKeyGenerator.next();
    final ResultSetFuture nextPartition = fetchFunction.apply(nextPartitionKey);

    LOG.trace("Initiated load of next partition in {} with key {}",
        nextPartition, nextPartitionKey);
    return nextPartition;
  }
}
